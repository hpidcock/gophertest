package runner

import (
	"text/template"
)

type Context struct {
	Targets []Target
}

type Target struct {
	ImportTest  bool
	TestName    string
	ImportXTest bool
	XTestName   string

	ImportPath string
	Directory  string

	Main       string
	Tests      []Test
	Benchmarks []Test
}

type Test struct {
	Package string
	Name    string
}

var Deps = []string{
	"bytes",
	"fmt",
	"io",
	"os",
	"os/exec",
	"path",
	"strconv",
	"testing",
	"testing/internal/testdeps",
	"time",
}

var Template = template.Must(template.New("").Parse(`// Code generated by 'gophertest'. DO NOT EDIT.

package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
	"strconv"
	"testing"
	"testing/internal/testdeps"
	"time"

{{range .Targets}}
{{if .ImportTest}}
	{{.TestName}} {{.ImportPath | printf "%q"}}
{{end}}
{{if .ImportXTest}}
	{{.XTestName}} {{.ImportPath | printf "%s_test" | printf "%q"}}
{{end}}
{{end}}
)

const pkgEnvName = "GOPHERTEST_PKG"
const concurrentEnvName = "GOPHERTEST_CONCURRENT"

type target struct {
	importPath string
	directory string
	tests []testing.InternalTest
	benchmarks []testing.InternalBenchmark
	examples []testing.InternalExample
	testMain func(*testing.M)
}

var selectedTarget *target

var targets = []target{
{{range .Targets}}
	target{
		importPath: {{.ImportPath | printf "%q"}},

		directory: {{.Directory | printf "%q"}},

		testMain: {{.Main}},

		tests: []testing.InternalTest{
{{range .Tests}}
			{"{{.Name}}", {{.Package}}.{{.Name}}},
{{end}}
		},

		benchmarks: []testing.InternalBenchmark{
{{range .Benchmarks}}
			{"{{.Name}}", {{.Package}}.{{.Name}}},
{{end}}
		},
	},
{{end}}
}

func init() {
	var err error
	pkg := os.Getenv(pkgEnvName)
	if pkg == "" {
		concurrent := 1
		if s := os.Getenv(concurrentEnvName); s != "" {
			concurrent, err = strconv.Atoi(s)
			if err != nil {
				fmt.Fprintf(os.Stderr, "error parsing %q: %v", concurrentEnvName, err)
				os.Exit(1)
			}
			if concurrent < 0 {
				concurrent = 1
			}
		}
		all(concurrent)
	}

	for _, t := range targets {
		if t.importPath == pkg {
			selectedTarget = &t
			break
		}
	}

	if selectedTarget == nil {
		selectedTarget = &target{
			importPath: pkg,
			testMain: defaultMain,
		}
	}

	testdeps.ImportPath = selectedTarget.importPath
}

func defaultMain(m *testing.M) {
	os.Exit(m.Run())
}

func main() {
	m := testing.MainStart(testdeps.TestDeps{}, selectedTarget.tests, selectedTarget.benchmarks, nil)
	selectedTarget.testMain(m)
}

func all(concurrent int) {
	bin := os.Args[0]
	if !path.IsAbs(bin) {
		cwd, err := os.Getwd()
		if err != nil {
			fmt.Fprintf(os.Stderr, "%v", err)
			os.Exit(1)
		}
		bin = path.Join(cwd, bin)
	}
	slot := make(chan struct{}, concurrent)
	for i := 0; i < concurrent; i++ {
		slot <- struct{}{}
	}
	mutex := make(chan struct{}, 1)
	mutex <- struct{}{}
	args := os.Args[1:]
	exitCode := 0
	for _, v := range targets {
		t := v
		<-slot
		os.Setenv(pkgEnvName, t.importPath)
		cmdArgs := []string{}
		for _, arg := range args {
			cmdArgs = append(cmdArgs, os.ExpandEnv(arg))
		}
		cmd := exec.Command(bin, cmdArgs...)
		cmd.Env = os.Environ()
		buffer := &bytes.Buffer{}
		if concurrent == 1 {
			cmd.Stdout = os.Stdout
			cmd.Stderr = os.Stderr
		} else {
			cmd.Stdout = buffer
			cmd.Stderr = buffer
		}
		wd, err := os.Stat(t.directory)
		if err != nil && !os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "%v", err)
			os.Exit(1)
		} else if wd.IsDir() {
			cmd.Dir = t.directory
		}
		go func() {
			start := time.Now()
			err := cmd.Run()
			failed := false
			if exitErr, ok := err.(*exec.ExitError); ok {
				failed = exitErr.ExitCode() != 0
			} else if err != nil {
				fmt.Fprintf(os.Stderr, "%v", err)
				os.Exit(1)
			}
			duration := time.Since(start).Round(time.Millisecond)
			<-mutex
			status := "ok"
			if failed {
				status = "fail"
				exitCode++
			}
			_, err = io.Copy(os.Stdout, buffer)
			if err != nil {
				fmt.Fprintf(os.Stderr, "%v", err)
				os.Exit(1)
			}
			fmt.Fprintf(os.Stdout, "%-4s\t%s\t%.3fs\n", status, t.importPath, duration.Seconds())
			mutex <- struct{}{}
			slot <- struct{}{}
		}()
	}
	for i := 0; i < concurrent; i++ {
		<-slot
	}
	os.Exit(exitCode)
}

`))
